<!DOCTYPE html>
<html lang="en">
<head>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Challenge!</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --blippi-orange: #FF6F00;
            --blippi-blue: #005A9C;
            --blippi-yellow: #f1c40f; /* Game title & active borders */
            --font-family-main: 'Fredoka', sans-serif;
            --bg-gradient-start: #2c3e50;
            --bg-gradient-end: #4ca1af;
            --text-light: #f0e68c;
            --white: #FFFFFF;
            --black: #000000;
            --vehicle-card-purple: #8A2BE2;
            --vehicle-card-blue: #007BFF;
        }

        body {
            font-family: var(--font-family-main);
            background-image: linear-gradient(to bottom, var(--bg-gradient-start), var(--bg-gradient-end));
            color: var(--white);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 15px;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .game-title-main {
            font-size: 2.5rem;
            font-weight: 600;
            color: var(--blippi-yellow);
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .menus-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 400px; /* Adjusted for simpler menu */
            margin-bottom: 15px;
        }

        .menu-container {
            padding: 10px 15px;
            border-radius: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .menu-title {
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 10px;
            color: var(--text-light);
        }

        .level-menu {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }

        .menu-button {
            padding: 8px 15px;
            border-radius: 20px;
            border: 2px solid transparent;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: var(--blippi-orange);
            color: var(--white);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .menu-button:hover:not(.active) {
            background-color: #e65c00;
            transform: translateY(-2px);
        }
        .menu-button.active {
            font-weight: 600;
            transform: scale(1.05);
            background-color: var(--blippi-blue);
            border-color: var(--blippi-yellow);
            color: var(--white);
        }

        #game-interaction-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
            margin: 0 auto 10px auto;
        }

        #action-button-container {
            text-align: center;
            margin-bottom: 8px;
        }

        #message-area {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--text-light);
            height: 25px;
            text-align: center;
            margin-bottom: 10px;
        }
        
        #actionButton {
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 25px;
            background-color: #2ecc71;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            min-width: 150px;
        }
        #actionButton:hover:not(:disabled) { background-color: #27ae60; }
        #actionButton:disabled { background-color: #9ca3af; cursor: not-allowed; opacity: 0.7; }

        .game-board-shell {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Always 2x2 for 4 cards */
            gap: 10px;
            width: 220px; /* (100 * 2) + 10 gap */
            height: 300px; /* (140 * 2) + 10 gap */
            margin: 15px auto;
            position: relative;
        }

        .card-shell {
            width: 100px; 
            height: 140px; 
            perspective: 1000px;
            cursor: pointer;
            transition: transform 0.6s, top 0.5s ease-in-out, left 0.5s ease-in-out, opacity 0.3s;
        }
        .card-shell-inner {
            position: relative; width: 100%; height: 100%; text-align: center;
            transition: transform 0.5s ease-in-out; transform-style: preserve-3d;
            border: 3px solid var(--blippi-yellow); border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.1);
        }
        .card-shell.flipped .card-shell-inner { transform: rotateY(180deg); }
        .card-shell.target-revealed .card-shell-inner { transform: rotateY(0deg); }
        .card-shell.incorrect-revealed .card-shell-inner { transform: rotateY(0deg); animation: shake 0.5s; }

        .card-shell-face {
            position: absolute; width: 100%; height: 100%; border-radius: 7px;
            display: flex; align-items: center; justify-content: center; padding: 5px;
            backface-visibility: hidden; -webkit-backface-visibility: hidden;
        }
        .card-shell-front { /* Shows the vehicle */ }
        .card-shell-back { 
            background-color: var(--blippi-blue);
            transform: rotateY(180deg);
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" font-size="70" fill="rgba(255,255,255,0.8)" style="filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.4));">?</text></svg>');
            background-size: 60%;
            background-repeat: no-repeat;
            background-position: center;
        }
        .card-svg { width: 90%; height: 90%; object-fit: contain; }
        .bg-vehicle-purple { background-color: var(--vehicle-card-purple); }
        .bg-vehicle-blue { background-color: var(--vehicle-card-blue); }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: none;
            justify-content: center; align-items: center; z-index: 1000;
            opacity: 0; transition: opacity 0.3s ease-in-out;
        }
        .modal-overlay.show { display: flex; opacity: 1; }
        .modal-content {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            padding: 2rem 3rem; border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); text-align: center;
            transform: scale(0.7); transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.show .modal-content { transform: scale(1); }
        .modal-content h2 { color: white; font-size: 2rem; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }

        @keyframes pulse-blippi {
            0%, 100% { box-shadow: 0 0 8px var(--blippi-yellow), 0 0 15px var(--blippi-yellow); transform: scale(1); }
            50% { box-shadow: 0 0 15px var(--blippi-yellow), 0 0 25px var(--blippi-yellow); transform: scale(1.03); }
        }
        .highlight-blippi-target .card-shell-inner { animation: pulse-blippi 1s infinite alternate; }
        @keyframes shake {
            0%, 100% { transform: translateX(0) rotateY(0deg); }
            25% { transform: translateX(-5px) rotateY(0deg); }
            50% { transform: translateX(5px) rotateY(0deg); }
            75% { transform: translateX(-5px) rotateY(0deg); }
        }

        /* Responsive adjustments for shell game board */
         @media (min-width: 380px) { /* Slightly larger cards */
            .game-board-shell { width: 250px; height: 340px; }
            .card-shell { width: 115px; height: 160px; }
        }
        @media (min-width: 640px) { /* Even larger for wider screens */
            .game-board-shell { width: 320px; height: 420px; }
            .card-shell { width: 150px; height: 200px; }
        }
    </style>
</head>
<body>
    <h1 class="game-title-main">Blippi Memory Challenge!</h1>

    <div class="menus-wrapper">
        <div class="menu-container level-menu-container">
            <h2 class="menu-title">Select Difficulty:</h2>
            <div class="level-menu" id="levelMenuContainer"></div>
        </div>
    </div>

    <div id="game-interaction-area">
        <div id="message-area">Select difficulty and click Start!</div>
        <div id="action-button-container">
            <button id="actionButton">Start Game</button>
        </div>
    </div>

    <div id="gameBoardShell" class="game-board-shell"></div>

    <div id="winModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2 id="winModalMessage">You found it!</h2>
        </div>
    </div>
    
    <script>
        const gameBoard = document.getElementById('gameBoardShell');
        const levelMenuContainer = document.getElementById('levelMenuContainer');
        const actionButton = document.getElementById('actionButton');
        const messageArea = document.getElementById('message-area');
        const winModalOverlay = document.getElementById('winModalOverlay');
        const winModalMessage = document.getElementById('winModalMessage');

        const appColors = { /* ... colors ... */ 
            blippiOrange: '#FF6F00', blippiBlue: '#005A9C', blippiYellow: '#f1c40f',
            vehicleCardPurple: '#8A2BE2', vehicleCardBlue: '#007BFF', white: '#FFFFFF', black: '#000000',
            excavatorYellow: '#FFFF00', gray: 'gray', skyblue: 'skyblue', green: 'green',
            lightgray: 'lightgray', red: 'red', blippiSkin: '#FFE0B2', blippiShoes: '#4A4A4A',
        };        // SVG for the back of cards (question mark) is now handled by CSS
        const vehicleDefinitions = [ /* ... definitions ... */ 
            { id: 'excavator', name: 'Excavator', getSvg: () => `<svg viewBox="0 0 100 100" class="card-svg"><rect x="10" y="60" width="80" height="20" fill="${appColors.excavatorYellow}"/><rect x="30" y="30" width="40" height="30" fill="${appColors.excavatorYellow}"/><circle cx="25" cy="85" r="10" fill="${appColors.black}"/><circle cx="75" cy="85" r="10" fill="${appColors.black}"/><path d="M 70 45 A 20 20 0 0 0 50 25 L 40 10 L 30 15 L 50 30" fill="${appColors.excavatorYellow}" stroke="${appColors.black}" stroke-width="3"/><rect x="25" y="5" width="15" height="10" fill="${appColors.gray}"/></svg>`, bgColorClass: 'bg-vehicle-purple' },
            { id: 'schoolbus', name: 'School Bus', getSvg: () => `<svg viewBox="0 0 100 80" class="card-svg"><rect x="5" y="20" width="90" height="40" fill="${appColors.blippiYellow}" rx="5"/><rect x="15" y="5" width="60" height="15" fill="${appColors.blippiYellow}" rx="3"/><rect x="20" y="25" width="15" height="10" fill="${appColors.skyblue}"/><rect x="40" y="25" width="15" height="10" fill="${appColors.skyblue}"/><rect x="60" y="25" width="15" height="10" fill="${appColors.skyblue}"/><circle cx="25" cy="65" r="10" fill="${appColors.black}"/><circle cx="75" cy="65" r="10" fill="${appColors.black}"/></svg>`, bgColorClass: 'bg-vehicle-blue' },
            { id: 'garbagetruck', name: 'Garbage Truck', getSvg: () => `<svg viewBox="0 0 100 80" class="card-svg"><rect x="5" y="30" width="40" height="30" fill="${appColors.white}"/><rect x="40" y="10" width="55" height="50" fill="${appColors.green}" rx="5"/><circle cx="20" cy="65" r="8" fill="${appColors.black}"/><circle cx="60" cy="65" r="8" fill="${appColors.black}"/><circle cx="80" cy="65" r="8" fill="${appColors.black}"/></svg>`, bgColorClass: 'bg-vehicle-blue' },
            { id: 'firetruck', name: 'Fire Truck', getSvg: () => `<svg viewBox="0 0 100 80" class="card-svg"><rect x="5" y="30" width="90" height="30" fill="${appColors.red}"/><rect x="10" y="15" width="30" height="15" fill="${appColors.red}"/><rect x="45" y="20" width="45" height="10" fill="${appColors.lightgray}"/><line x1="45" y1="20" x2="80" y2="5" stroke="${appColors.black}" stroke-width="3"/><line x1="50" y1="20" x2="85" y2="5" stroke="${appColors.black}" stroke-width="3"/><circle cx="25" cy="65" r="10" fill="${appColors.black}"/><circle cx="75" cy="65" r="10" fill="${appColors.black}"/></svg>`, bgColorClass: 'bg-vehicle-blue' }
        ];
        
        const LEVELS = { // numCards is fixed at 4 for shell game
            easy:   { name: 'Easy', numCards: 4, shuffleTimeFactor: 1.0, shuffleMoves: 8 }, // Slower
            medium: { name: 'Medium', numCards: 4, shuffleTimeFactor: 0.75, shuffleMoves: 12 }, // Medium
            hard:   { name: 'Hard', numCards: 4, shuffleTimeFactor: 0.5, shuffleMoves: 16 }  // Faster
        };
        let currentLevelKey = 'easy';

        let cardsOnBoard = []; 
        let targetCardDefinition = null;
        let cardPositions = []; 
        let gameActive = false;
        let canClickCard = false;
        let isShuffling = false;

        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array;}

        function createLevelButtons() {
            Object.keys(LEVELS).forEach(key => {
                const level = LEVELS[key];
                const button = document.createElement('button');
                button.id = `level-${key}-button`;
                button.classList.add('menu-button');
                if (key === currentLevelKey) button.classList.add('active');
                button.textContent = level.name;
                button.addEventListener('click', () => selectLevel(key));
                levelMenuContainer.appendChild(button);
            });
        }

        function selectLevel(levelKey) {
            if (gameActive || isShuffling) return;
            currentLevelKey = levelKey;
            Array.from(levelMenuContainer.children).forEach(btn => {
                btn.classList.toggle('active', btn.id === `level-${levelKey}-button`);
            });
            resetGameUI();
        }
        
        function createCardElement(vehicleDef) { /* ... same as before ... */ 
            const card = document.createElement('div'); card.className = 'card-shell'; 
            card.dataset.id = vehicleDef.id; card.dataset.name = vehicleDef.name;
            const cardInner = document.createElement('div'); cardInner.className = 'card-shell-inner';
            const cardFront = document.createElement('div');
            cardFront.className = `card-shell-face card-shell-front ${vehicleDef.bgColorClass}`;            cardFront.innerHTML = vehicleDef.getSvg();
            const cardBack = document.createElement('div'); cardBack.className = 'card-shell-face card-shell-back';
            // Question mark is handled by CSS background image
            cardInner.appendChild(cardFront); cardInner.appendChild(cardBack); card.appendChild(cardInner);
            card.addEventListener('click', () => handleCardClick(card));
            return card;
        }


        function setupBoard() {
            messageArea.textContent = "Getting ready...";
            actionButton.disabled = true;
            gameBoard.innerHTML = '';
            cardsOnBoard = [];
            cardPositions = [];

            const levelConf = LEVELS[currentLevelKey]; // numCards is always 4
            gameBoard.className = `game-board-shell`; // Grid is fixed 2x2

            // Ensure we have 4 unique vehicles for the 4 cards
            let availableVehicles = shuffleArray([...vehicleDefinitions]);
            if (availableVehicles.length < 4) {
                console.error("Not enough unique vehicle definitions for 4 cards!");
                messageArea.textContent = "Error: Need at least 4 vehicle types.";
                actionButton.disabled = false; actionButton.textContent = "Start Game";
                return;
            }
            let itemsForLevel = availableVehicles.slice(0, 4); // Take the first 4
            
            targetCardDefinition = itemsForLevel[Math.floor(Math.random() * itemsForLevel.length)];

            // Create the 4 cards. Their order in itemsForLevel is already shuffled.
            itemsForLevel.forEach(vehicleDef => {
                const cardElement = createCardElement(vehicleDef);
                cardsOnBoard.push(cardElement);
                gameBoard.appendChild(cardElement);
            });
            // The cardsOnBoard array is now in the shuffled visual order for initial display

            setTimeout(() => { 
                const boardRect = gameBoard.getBoundingClientRect();
                cardsOnBoard.forEach(cardEl => {
                    const rect = cardEl.getBoundingClientRect();
                    cardPositions.push({
                        top: rect.top - boardRect.top,
                        left: rect.left - boardRect.left
                    });
                });

                messageArea.textContent = `Find the ${targetCardDefinition.name}!`;
                const targetCardElement = cardsOnBoard.find(c => c.dataset.id === targetCardDefinition.id);
                if (targetCardElement) {
                    targetCardElement.classList.add('highlight-blippi-target');
                }

                setTimeout(() => {
                    if (targetCardElement) targetCardElement.classList.remove('highlight-blippi-target');
                    flipAllToBackAndPrepareShuffle();
                }, 3000); 
            }, 100);
        }

        function flipAllToBackAndPrepareShuffle() { /* ... same as before ... */ 
            messageArea.textContent = 'Watch closely...';
            cardsOnBoard.forEach(card => card.classList.add('flipped'));
            setTimeout(startShuffleAnimation, 1000);
        }

        async function startShuffleAnimation() {
            if (isShuffling || cardPositions.length !== cardsOnBoard.length) return;
            
            isShuffling = true;
            canClickCard = false;
            actionButton.disabled = true;
            messageArea.textContent = 'Shuffling!';

            cardsOnBoard.forEach((card, index) => {
                card.style.position = 'absolute';
                // Use the *stored* initial grid position corresponding to this card's current index in cardsOnBoard
                // This ensures cards "lift" from their correct spots if cardsOnBoard was pre-shuffled visually.
                const initialPos = cardPositions[index];
                card.style.top = initialPos.top + 'px';
                card.style.left = initialPos.left + 'px';
            });

            // animatedCardsData now tracks the element and which *original slot position* it's currently in or moving to.
            // The slot indices (0, 1, 2, 3) correspond to the entries in cardPositions.
            let animatedCardsData = cardsOnBoard.map((card, index) => ({
                element: card,
                currentVisualSlotIndex: index // The index of the cardPosition it's currently at
            }));

            const levelConf = LEVELS[currentLevelKey];
            const numShuffleMoves = levelConf.shuffleMoves;
            const shuffleSpeedFactor = levelConf.shuffleTimeFactor;

            for (let i = 0; i < numShuffleMoves; i++) {
                // Pick two different *elements* to swap.
                let elementIdx1 = Math.floor(Math.random() * animatedCardsData.length);
                let elementIdx2 = Math.floor(Math.random() * animatedCardsData.length);
                while (elementIdx2 === elementIdx1) {
                    elementIdx2 = Math.floor(Math.random() * animatedCardsData.length);
                }

                const cardData1 = animatedCardsData[elementIdx1];
                const cardData2 = animatedCardsData[elementIdx2];

                // Target visual positions are the *original grid positions* of each other's *current slots*.
                const targetVisualPosForCard1 = cardPositions[cardData2.currentVisualSlotIndex];
                const targetVisualPosForCard2 = cardPositions[cardData1.currentVisualSlotIndex];

                cardData1.element.style.top = targetVisualPosForCard1.top + 'px';
                cardData1.element.style.left = targetVisualPosForCard1.left + 'px';
                
                cardData2.element.style.top = targetVisualPosForCard2.top + 'px';
                cardData2.element.style.left = targetVisualPosForCard2.left + 'px';

                // Swap their currentVisualSlotIndex trackers
                let tempSlotIndex = cardData1.currentVisualSlotIndex;
                cardData1.currentVisualSlotIndex = cardData2.currentVisualSlotIndex;
                cardData2.currentVisualSlotIndex = tempSlotIndex;
                
                await new Promise(resolve => setTimeout(resolve, 400 * shuffleSpeedFactor));
            }
            
            // The elements are now visually in their final shuffled spots.
            // We need to update the `cardsOnBoard` array to reflect this new visual order for the DOM.
            // Sort animatedCardsData by the slot they ended up in to reconstruct the visual order.
            cardsOnBoard = animatedCardsData
                .sort((a, b) => a.currentVisualSlotIndex - b.currentVisualSlotIndex)
                .map(data => data.element);

            // Reset styles and re-append to DOM in the new visual order to go back to grid flow.
            // This step ensures the DOM order matches the visual order if that's important later,
            // and cleans up absolute positioning.
            cardsOnBoard.forEach(card => {
                card.style.position = '';
                card.style.top = '';
                card.style.left = '';
            });
            gameBoard.innerHTML = ''; // Clear board
            cardsOnBoard.forEach(card => gameBoard.appendChild(card)); // Re-add in new visual order

            isShuffling = false;
            canClickCard = true;
            actionButton.disabled = false; 
            messageArea.textContent = `Where is the ${targetCardDefinition.name}? Click a card!`;
        }

        function handleCardClick(clickedCardElement) { /* ... same as before ... */ 
            if (!canClickCard || isShuffling || !gameActive) return;
            canClickCard = false; actionButton.disabled = true;
            clickedCardElement.classList.remove('flipped'); 
            if (clickedCardElement.dataset.id === targetCardDefinition.id) {
                clickedCardElement.classList.add('target-revealed');
                messageArea.textContent = `Yeah! You found the ${targetCardDefinition.name}!`;
                winModalMessage.textContent = `You found the ${targetCardDefinition.name}!`;
                winModalOverlay.classList.add('show');
                setTimeout(() => { winModalOverlay.classList.remove('show'); resetGameUI('Play Again?'); }, 2500);
            } else {
                clickedCardElement.classList.add('incorrect-revealed');
                messageArea.textContent = `Oops! That's not the ${targetCardDefinition.name}.`;
                setTimeout(() => {
                    const correctCardEl = cardsOnBoard.find(c => c.dataset.id === targetCardDefinition.id && c !== clickedCardElement);
                    if (correctCardEl) { correctCardEl.classList.remove('flipped'); correctCardEl.classList.add('target-revealed', 'highlight-blippi-target'); }
                    setTimeout(() => {
                        if (correctCardEl) {
                            correctCardEl.classList.remove('highlight-blippi-target');
                            if(clickedCardElement.dataset.id !== targetCardDefinition.id) {
                                correctCardEl.classList.add('flipped'); correctCardEl.classList.remove('target-revealed');
                            }
                        }
                        clickedCardElement.classList.add('flipped'); clickedCardElement.classList.remove('incorrect-revealed');
                        resetGameUI('Try Again?');
                    }, 2000);
                }, 1500);
            }
        }
        
        function resetGameUI(buttonText = "Start Game") { /* ... same as before ... */ 
            gameActive = false; canClickCard = false; isShuffling = false;
            actionButton.textContent = buttonText; actionButton.disabled = false;
            if (buttonText === "Start Game" || buttonText === "Play Again?" || buttonText === "Try Again?") {
                 messageArea.textContent = "Select difficulty and click Start!";
                 if (buttonText === "Try Again?") messageArea.textContent = "Give it another go!";
            }
        }

        actionButton.addEventListener('click', () => { /* ... same as before ... */ 
             if (actionButton.textContent === "Start Game" || actionButton.textContent === "Play Again?" || actionButton.textContent === "Try Again?") {
                gameActive = true; setupBoard();
            }
        });

        createLevelButtons();
        resetGameUI();
        messageArea.textContent = "Select difficulty and click Start!";

    </script>
</body>
</html>