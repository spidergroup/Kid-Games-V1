<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-J0PVJ95F71"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-J0PVJ95F71');
    </script>
    <title>Memory Match Mania!</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600&display=swap');
        body {
            font-family: 'Fredoka', sans-serif;
            background-image: linear-gradient(to bottom, #2c3e50, #4ca1af);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 15px;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .game-title {
            font-size: 2.5rem; font-weight: 600; color: #f1c40f;
            margin-bottom: 15px; text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .menus-wrapper {
            display: flex; flex-direction: column; gap: 10px;
            width: 100%; max-width: 850px;
            margin-bottom: 15px;
        }
        .menu-container {
            padding: 10px 15px; border-radius: 12px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .menu-title {
            font-size: 1.1rem; font-weight: 600; text-align: center;
            margin-bottom: 10px; color: #f0e68c;
        }
        .category-menu, .level-menu { display: flex; flex-wrap: wrap; justify-content: center; gap: 8px; }
        .menu-button {
            padding: 8px 15px; border-radius: 20px; border: 2px solid transparent;
            font-size: 0.9rem; font-weight: 500; cursor: pointer;
            transition: all 0.2s ease-in-out;
            background-color: rgba(243, 156, 18, 0.75); color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .menu-button:hover:not(.active) { background-color: rgba(230, 126, 34, 0.85); transform: translateY(-2px); }
        .menu-button.active {
            font-weight: 600; transform: scale(1.05);
            background-color: #e67e22; border-color: #f1c40f; color: white;
        }
        .menu-button.pets.active { background-color: #ff7675; border-color: #fab1a0; color: #2d3436; }
        .menu-button.wildAnimals.active { background-color: #fdcb6e; border-color: #ffeaa7; color: #2d3436; }
        .menu-button.fruits.active { background-color: #55efc4; border-color: #00b894; color: #2d3436; }
        .menu-button.shapes.active { background-color: #74b9ff; border-color: #0984e3; color: #2d3436; }
        .menu-button.alphabet.active { background-color: #a29bfe; border-color: #6c5ce7; color: #2d3436; }
        .menu-button.numbers.active { background-color: #ffeaa7; border-color: #fdcb6e; color: #2d3436; }
        .menu-button.easy.active { background-color: #55efc4; border-color: #00b894; color: #2d3436;}
        .menu-button.medium.active { background-color: #74b9ff; border-color: #0984e3; color: #2d3436;}
        .menu-button.hard.active { background-color: #ff7675; border-color: #fab1a0; color: #2d3436;}        #game-interaction-area {
            display: flex; flex-direction: column; align-items: center;
            width: 100%; max-width: 650px; margin: 0 auto 10px auto;
        }        #action-button-container { 
            text-align: center; 
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
            flex-wrap: nowrap;
        }        #game-time-display {
            font-size: 0.9rem;
            font-weight: 500;
            color: #f1c40f;
            background-color: rgba(44, 62, 80, 0.6);
            padding: 8px 15px;
            border-radius: 20px;
            display: none;
            text-shadow: 1px 1px 2px black;
            min-width: 90px;
            text-align: center;
            max-width: 110px;
        }        #actionButton {
            padding: 8px 15px; font-size: 0.9rem; font-weight: 500;
            border-radius: 20px; background-color: #2ecc71;
            color: white; border: none; cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); min-width: 120px;
        }
        #actionButton:hover:not(:disabled) { background-color: #27ae60; }
        #actionButton.pause { background-color: #f39c12; }
        #actionButton.pause:hover:not(:disabled) { background-color: #e67e22; }
        #actionButton.resume { background-color: #3498db; }
        #actionButton.resume:hover:not(:disabled) { background-color: #2980b9; }
        #actionButton:disabled { background-color: #9ca3af; cursor: not-allowed; opacity: 0.7; }        #stopButton {
            padding: 8px 15px;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: 20px;
            background-color: #e74c3c;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            flex: 1;
            max-width: 100px;
            min-width: 80px;
        }
        #stopButton:hover {
            background-color: #c0392b;
        }

        #message-area {
            font-size: 1.1rem; font-weight: 500; color: #f0e68c; height: 25px;
            text-align: center;
        }

        #game-board {
            display: grid; gap: 10px; width: 100%; max-width: 850px;
            margin: 0 auto; perspective: 1000px;
        }
        .card {
            aspect-ratio: 1 / 1; position: relative; transform-style: preserve-3d;
            transition: transform 0.6s; cursor: pointer; border-radius: 10px;
            background-color: rgba(255,255,255,0.15); box-shadow: 0 3px 7px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .card.showing-content {
            transform: rotateY(180deg);
        }
        .card.showing-front {
            transform: rotateY(0deg);
        }
        .card.matched {
            transform: rotateY(180deg) !important; /* Force open */
            cursor: default;
            /* opacity: 0.9; */
            box-shadow: 0 0 15px #f1c40f, 0 0 5px #f1c40f inset;
            border-color: #f1c40f;
        }

        .card-face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            display: flex; justify-content: center; align-items: center;
            border-radius: 9px; overflow: hidden;
        }
        .card-front {
            background-color: rgba(41, 128, 185, 0.7);
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" font-size="70" fill="rgba(255,255,255,0.8)" style="filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.4));">?</text></svg>');
            background-size: 50%; background-repeat: no-repeat; background-position: center;
        }
        .card-back {
            background-color: rgba(255, 255, 255, 0.25);
            transform: rotateY(180deg);
        }
        .card-back img {
            max-width: 95%;
            max-height: 95%;
            object-fit: contain;
            border-radius: 5px;
        }
        .card-back span {
            font-size: clamp(1.8rem, 10vw / var(--card-cols, 4), 3rem);
            font-weight: 600; padding: 5px; text-align: center;
            color: #f0e68c; text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }
        a.home-button {
            display: inline-block; margin-top: 20px; padding: 10px 20px;
            background-color: #e74c3c; color: white; text-decoration: none;
            border-radius: 20px; font-size: 1rem; font-weight: 500;
            box-shadow: 0 3px #c0392b;
        }
        a.home-button:active { transform: translateY(1px); box-shadow: 0 2px #c0392b; }

    /* --- Firework Animation --- */
    .firework {
        position: fixed;
        left: 0; top: 0; width: 100vw; height: 100vh;
        pointer-events: none;
        z-index: 2000;
    }
    .firework > .before, .firework > .after {
        position: absolute;
        width: 5px;
        height: 5px;
        border-radius: 50%;
        content: '';
        box-shadow: 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff, 0 0 #fff;
        animation: bang 1s ease-out forwards, gravity 1s ease-in forwards, position 5s linear forwards;
    }
    .firework > .after {
        animation-delay: 1.25s, 1.25s, 1.25s;
        animation-duration: 1.25s, 1.25s, 6.25s;
    }
    @keyframes bang {
        to {
            box-shadow:
                0 0 #fff,
                50px -80px hsl(0,100%,50%),
                -60px -60px hsl(30,100%,50%),
                80px 0 hsl(60,100%,50%),
                -80px 0 hsl(90,100%,50%),
                60px 60px hsl(120,100%,50%),
                -50px 80px hsl(150,100%,50%),
                0 90px hsl(180,100%,50%),
                0 -90px hsl(210,100%,50%),
                90px 0 hsl(240,100%,50%),
                -90px 0 hsl(270,100%,50%),
                70px 70px hsl(300,100%,50%),
                -70px 70px hsl(330,100%,50%),
                30px -100px hsl(45,100%,50%),
                -30px -100px hsl(75,100%,50%),
                100px 30px hsl(105,100%,50%),
                -100px 30px hsl(135,100%,50%),
                100px -30px hsl(165,100%,50%),
                -100px -30px hsl(195,100%,50%),
                30px 100px hsl(225,100%,50%),
                -30px 100px hsl(255,100%,50%),
                60px -90px hsl(285,100%,50%),
                -60px -90px hsl(315,100%,50%),
                90px 60px hsl(345,100%,50%),
                -90px 60px hsl(15,100%,50%),
                0 0 #fff;
        }
    }
    @keyframes gravity {
        to {
            transform: translateY(200px);
            opacity: 0;
        }
    }
    @keyframes position {
        0%, 19.9% {
            margin-top: 10%;
            margin-left: 40%;
        }
        20%, 39.9% {
            margin-top: 40%;
            margin-left: 30%;
        }
        40%, 59.9% {
            margin-top: 20%;
            margin-left: 70%;
        }
        60%, 79.9% {
            margin-top: 30%;
            margin-left: 20%;
        }
        80%, 99.9% {
            margin-top: 30%;
            margin-left: 80%;
        }
    }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .modal {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            padding: 2rem 3rem;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            transform: scale(0.7);
            transition: transform 0.3s ease-in-out;
        }

        .modal h2 {
            color: white;
            font-size: 2rem;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .modal-overlay.show {
            opacity: 1;
        }

        .modal-overlay.show .modal {
            transform: scale(1);
        }
    </style>
</head>
<body>

    <h1 class="game-title">Memory Match Mania!</h1>
    
    <div class="game-desc" style="max-width: 850px; margin: 0 auto 18px auto; color: #f0e68c; font-size: .9rem; text-align: center;">
      <b>How to play:</b> Flip two cards at a time to find matching pairs. Match all pairs before time runs out!
      <ul style="margin: 10px 0 0 0; padding-left: 1.2em; text-align: left; display: inline-block;">
        <li>Pick a category and level.</li>
        <li>Press Start and memorize card positions.</li>
        <li>Flip cards to find all the pairs!</li>
      </ul>
    </div>

    <div class="menus-wrapper">
        <div class="menu-container category-menu-container">
            <h2 class="menu-title">Choose a Category:</h2>
            <div class="category-menu" id="categoryMenu"></div>
        </div>
        <div class="menu-container level-menu-container">
            <h2 class="menu-title">Select a Level:</h2>
            <div class="level-menu" id="levelMenu"></div>
        </div>
    </div>

    <div id="game-interaction-area">
        <div id="action-button-container">
            <div id="game-time-display">Time: 00:00</div>
            <button id="actionButton">Start Game</button>
            <button id="stopButton" style="display: none;">Stop</button>
        </div>
        <div id="message-area">Select category & level!</div>
    </div>

    <div id="game-board"></div>
    <a href="index.html" class="home-button">🏠 Back to Main Menu</a>

    <script>
        const gameBoard = document.getElementById('game-board');
        const categoryMenu = document.getElementById('categoryMenu');
        const levelMenu = document.getElementById('levelMenu');
        const actionButton = document.getElementById('actionButton');
        const stopButton = document.getElementById('stopButton');
        const messageArea = document.getElementById('message-area');
        const gameTimeDisplayElement = document.getElementById('game-time-display');

        const ASSET_BASE_PATH = 'memory-game-assets/';

        const CATEGORIES = {
            pets: { name: 'Pets 🐾', items: ['cat', 'dog', 'hamster', 'bunny', 'fish', 'turtle', 'bird', 'guinea-pig'], folder: 'pets/', type: 'image' },
            // wildAnimals: { name: 'Wild Animals 🐅', items: ['lion', 'tiger', 'elephant', 'zebra', 'monkey', 'giraffe', 'bear', 'wolf'], folder: 'wild-animals/', type: 'image' },
            fruits: { name: 'Fruits 🍓', items: ['apple', 'banana', 'orange', 'grapes', 'strawberry', 'watermelon', 'pineapple', 'kiwi'], folder: 'fruits/', type: 'image' },
            // shapes: { name: 'Shapes 🔷', items: ['circle', 'square', 'triangle', 'rectangle', 'star', 'heart', 'oval', 'diamond'], folder: 'shapes/', type: 'image' },
            alphabet: { name: 'Alphabet A-L', items: 'ABCDEFGHIJKL'.split(''), folder: 'alphabet/', type: 'text' },
            numbers: { name: 'Numbers 1-12', items: Array.from({length: 12}, (_, i) => (i + 1).toString()), folder: 'numbers/', type: 'text' },
        };
        const LEVELS = {
            easy:   { name: 'Easy 😊', pairs: 4, cols: 4, rows: 2, gameTime: 60000 },
            medium: { name: 'Medium 🤔', pairs: 6, cols: 4, rows: 3, gameTime: 120000 },
            hard:   { name: 'Hard 🤯', pairs: 8, cols: 4, rows: 4, gameTime: 180000 }
        };

        let currentCategory = 'pets';
        let currentLevelKey = 'easy';
        let cards = []; // This will store the DOM elements of the cards
        let flippedCards = []; // Stores the 1 or 2 cards currently flipped by the player
        let matchedPairs = 0;
        let canFlip = false; // Controls if the player can flip cards
        let gameActive = false;
        let isPaused = false;

        let preGameCountdownTimerId;

        // --- Firework celebration function ---
        function showFireworks(times = 3) {
            const fireworks = [];
            for (let i = 0; i < times; i++) {
                const firework = document.createElement('div');
                firework.className = 'firework';
                firework.innerHTML = '<div class="before"></div><div class="after"></div>';
                firework.style.animationDelay = `${i * 0.2}s`;
                document.body.appendChild(firework);
                fireworks.push(firework);
            }
            setTimeout(() => {
                fireworks.forEach(fw => { if (fw.parentNode) fw.parentNode.removeChild(fw); });
            }, 2500);
        }
        let mainGameTimerId;
        let gameEndTimeStamp;
        let timeRemainingOnPause;
        let visualGameTimeUpdaterId;

        // --- UTILITY FUNCTIONS ---
        function formatTime(ms) {
            let totalSeconds = Math.ceil(ms / 1000);
            let minutes = Math.floor(totalSeconds / 60);
            let seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateVisualGameTime() {
            if (isPaused && timeRemainingOnPause >= 0) {
                gameTimeDisplayElement.textContent = `Time: ${formatTime(timeRemainingOnPause)}`;
            } else if (gameActive && !isPaused) {
                const remaining = gameEndTimeStamp - Date.now();
                gameTimeDisplayElement.textContent = `Time: ${formatTime(Math.max(0, remaining))}`;
            } else {
                 gameTimeDisplayElement.textContent = `Time: ${formatTime(LEVELS[currentLevelKey].gameTime)}`;
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function getItemPath(categoryData, item) {
            if (categoryData.type === 'image') {
                const basePath = ASSET_BASE_PATH.endsWith('/') ? ASSET_BASE_PATH : ASSET_BASE_PATH + '/';
                const folder = categoryData.folder.startsWith('/') ? categoryData.folder.substring(1) : categoryData.folder;
                // Use .jpg for both 'pets/' and 'fruits/'
                let extension = 'jpg';
                return `${basePath}${folder}${item.toLowerCase()}.${extension}`;
            }
            return null;
        }

        // --- CARD STATE MANAGEMENT ---
        function setCardToShowFront(card) {
            if (card.classList.contains('matched')) return; // Matched cards should not be flipped to front
            card.classList.remove('showing-content');
            card.classList.add('showing-front');
            // console.log(`Card ${card.dataset.value} set to SHOWING FRONT`);
        }

        function setCardToShowContent(card) {
            // If it's already matched, the .matched class handles its appearance.
            // This is for revealing a card during a flip.
            if (card.classList.contains('matched')) return;
            card.classList.remove('showing-front');
            card.classList.add('showing-content');
            // console.log(`Card ${card.dataset.value} set to SHOWING CONTENT`);
        }

        function markCardAsMatched(card) {
            card.classList.add('matched');
            // Remove state classes as .matched now dictates appearance
            card.classList.remove('showing-front');
            card.classList.add('showing-content');
            card.dataset.isMatched = "true"; // Explicit data attribute for easier checking
            console.log(`Card ${card.dataset.value} MARKED AS MATCHED`);
        }


        // --- MENU FUNCTIONS ---
        function createMenuButton(id, text, type, clickHandler, parentElement, isActive = false) {
            const button = document.createElement('button');
            button.id = `${type}-${id}-button`;
            button.classList.add('menu-button', id);
            button.textContent = text;
            if (isActive) button.classList.add('active');
            button.addEventListener('click', () => clickHandler(id));
            parentElement.appendChild(button);
        }
        function selectCategory(categoryKey) {
            // Allow changes when game is not active OR when game is paused
            if (gameActive && !isPaused) {
                console.log("Cannot change category while game is active and not paused");
                return;
            }
            
            console.log(`--- Selecting Category: ${categoryKey} ---`);
            currentCategory = categoryKey;
            updateMenuState(categoryMenu, `category-${categoryKey}-button`);
            
            // Always reset the game when category changes
            clearAllTimers();
            gameActive = false;
            isPaused = false;
            canFlip = false;
            matchedPairs = 0;
            flippedCards = [];
            
            resetAndPrepareGame();
        }
        function selectLevel(levelKey) {
            // Allow changes when game is not active OR when game is paused
            if (gameActive && !isPaused) {
                console.log("Cannot change level while game is active and not paused");
                return;
            }
            
            console.log(`--- Selecting Level: ${levelKey} ---`);
            currentLevelKey = levelKey;
            updateMenuState(levelMenu, `level-${levelKey}-button`);
            
            // Always reset the game when level changes
            clearAllTimers();
            gameActive = false;
            isPaused = false;
            canFlip = false;
            matchedPairs = 0;
            flippedCards = [];
            
            resetAndPrepareGame();
        }
        function updateMenuState(menuElement, activeButtonId) {
            Array.from(menuElement.children).forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(activeButtonId);
            if (activeBtn) activeBtn.classList.add('active');
        }
        function initializeMenus() {
            Object.keys(CATEGORIES).forEach((key, index) => {
                createMenuButton(key, CATEGORIES[key].name, 'category', selectCategory, categoryMenu, index === 0);
            });
            Object.keys(LEVELS).forEach((key, index) => {
                createMenuButton(key, LEVELS[key].name, 'level', selectLevel, levelMenu, index === 0);
            });
        }


        // --- GAME BOARD & CARD CREATION ---
        function createGameBoard() {
            console.log("--- Creating Game Board ---");
            gameBoard.innerHTML = '';
            cards = []; // Reset the global array of card DOM elements
            flippedCards = [];
            matchedPairs = 0;
            // canFlip is set during startGameSequence

            const levelConf = LEVELS[currentLevelKey];
            const categoryData = CATEGORIES[currentCategory];
            gameBoard.style.setProperty('--card-cols', levelConf.cols);
            let availableItems = [...categoryData.items];

            if (availableItems.length < levelConf.pairs) {
                console.warn(`Warning: Category '${currentCategory}' has only ${availableItems.length} unique items, but level '${currentLevelKey}' requires ${levelConf.pairs} pairs. Repeating items.`);
                let baseItems = [...categoryData.items];
                if (baseItems.length === 0) {
                    messageArea.textContent = "Error: Category has no items!"; return false;
                }
                while (availableItems.length < levelConf.pairs) {
                    availableItems.push(baseItems[availableItems.length % baseItems.length]);
                }
            }
            const selectedItems = shuffleArray(availableItems).slice(0, levelConf.pairs);
            if (selectedItems.length < levelConf.pairs) {
                 messageArea.textContent = `Error: Not enough items for ${levelConf.pairs} pairs.`; return false;
            }
            let gameItems = shuffleArray([...selectedItems, ...selectedItems]);
            gameBoard.style.gridTemplateColumns = `repeat(${levelConf.cols}, 1fr)`;

            gameItems.forEach(itemValue => {
                const card = document.createElement('div');
                card.classList.add('card');
                // Initial state for "Memorize!" phase: showing content
                card.classList.add('showing-front');
                card.dataset.value = itemValue;
                delete card.dataset.isMatched; // Ensure no leftover matched state

                const cardFront = document.createElement('div'); cardFront.classList.add('card-face', 'card-front');
                const cardBack = document.createElement('div'); cardBack.classList.add('card-face', 'card-back');

                if (categoryData.type === 'image') {
                    const img = document.createElement('img');
                    const imagePath = getItemPath(categoryData, itemValue);
                    img.src = imagePath; img.alt = itemValue;
                    img.onerror = () => {
                        console.error(`Failed to load image: ${imagePath}. Displaying text instead.`);
                        const textSpan = document.createElement('span'); textSpan.textContent = itemValue.toString().toUpperCase();
                        cardBack.innerHTML = ''; cardBack.appendChild(textSpan);
                    };
                    cardBack.appendChild(img);
                } else {
                    const textSpan = document.createElement('span');
                    textSpan.textContent = itemValue.toString().toUpperCase();
                    // Make numbers 100% bigger for Numbers 1-12 category
                    if (currentCategory === 'numbers') {
                        textSpan.style.fontSize = 'clamp(5.4rem, 30vw / var(--card-cols, 4), 9rem)';
                        // Assign a unique color for each number 1-12                        
                        const numberColors = [
                            '#83c5be', // 1 - Seafoam Green
                            '#fcf6bd', // 2 - Light Yellow
                            '#d0f4de', // 3 - Mint Green
                            '#a9def9', // 4 - Light Blue
                            '#e4c1f9', // 5 - Lavender
                            '#fcbf49', // 6 - Golden Yellow
                            '#e29578', // 7 - Coral
                            '#e5989b', // 8 - Rose Pink
                            '#06d6a0', // 9 - Turquoise
                            '#a7c957', // 10 - Lime Green
                            '#8338ec', // 11 - Purple
                            '#fefae0'  // 12 - Cream
                        ];
                        const idx = parseInt(itemValue, 10) - 1;
                        if (!isNaN(idx) && idx >= 0 && idx < numberColors.length) {
                            textSpan.style.color = numberColors[idx];
                        }
                    } else if (currentCategory === 'alphabet') {
                        textSpan.style.fontSize = 'clamp(5.4rem, 30vw / var(--card-cols, 4), 9rem)';
                        // Assign a unique, brighter color for each letter A-L
                        const letterColors = [                            
                            '#FF1744', // A - Bright Red
                            '#D500F9', // B - Bright Purple
                            '#2979FF', // C - Bright Blue
                            '#1DE9B6', // D - Bright Teal
                            '#00E676', // E - Bright Green
                            '#FFEA00', // F - Bright Yellow
                            '#FF9100', // G - Bright Orange
                            '#A1887F', // H - Lighter Brown
                            '#BDBDBD', // I - Lighter Gray
                            '#00B0FF', // J - Bright Light Blue
                            '#C6FF00', // K - Bright Lime
                            '#FF4081'  // L - Bright Pink
                        ];
                        const idx = 'ABCDEFGHIJKL'.indexOf(itemValue.toString().toUpperCase());
                        if (idx >= 0 && idx < letterColors.length) {
                            textSpan.style.color = letterColors[idx];
                        }
                    }
                    cardBack.appendChild(textSpan);
                }
                card.appendChild(cardFront); card.appendChild(cardBack);
                // Event listener is added here. Its behavior is controlled by flags.
                card.addEventListener('click', () => handleCardClick(card));
                gameBoard.appendChild(card);
                cards.push(card);
            });
            console.log(`Game board created with ${cards.length} cards. All showing content.`);
            return true;
        }


        // --- GAME LOGIC ---
        function handleCardClick(cardElement) {
            console.log(`Card clicked: ${cardElement.dataset.value}, Matched: ${cardElement.dataset.isMatched}, CanFlip: ${canFlip}, Flipped: ${flippedCards.length}`);
            // --- MOST IMPORTANT GUARD ---
            if (cardElement.dataset.isMatched === "true" || !canFlip || !gameActive || isPaused || flippedCards.includes(cardElement) || flippedCards.length >= 2) {
                console.log("Flip rejected by guard.");
                return;
            }

            if (cardElement.classList.contains('showing-front')) {
                console.log(`Flipping ${cardElement.dataset.value} to show content.`);
                setCardToShowContent(cardElement); // Reveal card
                flippedCards.push(cardElement);

                if (flippedCards.length === 2) {
                    console.log("Two cards flipped. Checking for match...");
                    checkForMatch();
                }
            } else {
                // This case should ideally not happen if logic is correct after memorize phase
                console.warn(`Clicked card ${cardElement.dataset.value} that was not showing front.`);
            }
        }

        function checkForMatch() {
            canFlip = false; // Disable flipping while checking
            const [card1, card2] = flippedCards;
            console.log(`Checking match: ${card1.dataset.value} vs ${card2.dataset.value}`);

            if (card1.dataset.value === card2.dataset.value) {
                console.log("MATCH FOUND!");
                messageArea.textContent = "It's a Match! 🎉";

                markCardAsMatched(card1);
                markCardAsMatched(card2);

                matchedPairs++;
                flippedCards = []; // Reset for the next pair

                if (matchedPairs === LEVELS[currentLevelKey].pairs) {
                    console.log("All pairs matched!");
                    endGame(true, "You matched them all!");
                } else {
                    canFlip = true; // Allow flipping for next pair immediately
                }
            } else {
                console.log("NO MATCH.");
                messageArea.textContent = "Try Again... 🤔";
                // Delay flipping back non-matches
                setTimeout(() => {
                    console.log(`Timeout: Flipping back ${card1.dataset.value} and ${card2.dataset.value}`);
                    // Check game state again in case it changed during timeout (e.g., paused, game over)
                    if (!gameActive || isPaused) {
                        console.log("Timeout: Game not active or paused. Not flipping back.");
                        // If game ended or paused, we might not want to flip them back,
                        // or we might want to clear flippedCards regardless.
                        // For now, just ensure canFlip is managed.
                        flippedCards = [];
                        if (gameActive && !isPaused) canFlip = true; // Only if game is still on
                        return;
                    }

                    // Only flip back if they haven't magically become matched
                    // (shouldn't happen, but good safeguard)
                    if (card1.dataset.isMatched !== "true") setCardToShowFront(card1);
                    if (card2.dataset.isMatched !== "true") setCardToShowFront(card2);

                    flippedCards = [];
                    canFlip = true; // Re-enable flipping AFTER cards are reset
                    messageArea.textContent = "Keep going!";
                }, 1200);
            }
        }

        function clearAllTimers() {
            clearInterval(preGameCountdownTimerId); clearTimeout(mainGameTimerId); clearInterval(visualGameTimeUpdaterId);
            preGameCountdownTimerId = null; mainGameTimerId = null; visualGameTimeUpdaterId = null;
        }

        function updateActionButtonState(state, countdownValue = 0) {
            actionButton.classList.remove('start', 'pause', 'resume');
            actionButton.disabled = false;
            switch (state) {
                case 'initial': case 'play_again':
                    actionButton.textContent = 'Start Game'; actionButton.classList.add('start'); break;
                case 'pre_game_countdown':
                    actionButton.textContent = `Memorize! (${countdownValue})`; actionButton.classList.add('start'); actionButton.disabled = true; break;
                case 'active':
                    actionButton.textContent = 'Pause'; actionButton.classList.add('pause'); break;
                case 'paused':
                    actionButton.textContent = 'Resume'; actionButton.classList.add('resume'); break;
                case 'disabled_setting_up':
                     actionButton.textContent = 'Setting up...'; actionButton.disabled = true; break;
            }
        }

        function resetAndPrepareGame() {
            console.log("--- Reset And Prepare Game ---");
            clearAllTimers();
            gameActive = false; isPaused = false; canFlip = false;
            matchedPairs = 0; flippedCards = [];

            if (!createGameBoard()) {
                messageArea.textContent = "Error creating board. Check console.";
                updateActionButtonState('initial'); actionButton.disabled = true; return;
            }
            messageArea.textContent = "Cards ready! Hit Start to memorize.";
            updateActionButtonState('initial');
            document.querySelectorAll('.menu-button').forEach(btn => btn.disabled = false);
            gameTimeDisplayElement.style.display = 'none';
        }

        async function startGameSequence() {
            if (gameActive) { console.log("Game sequence aborted: game already active."); return; }
            console.log("--- Starting Game Sequence ---");

            updateActionButtonState('disabled_setting_up');
            messageArea.textContent = "Getting ready to memorize...";
            document.querySelectorAll('.menu-button').forEach(btn => btn.disabled = true);

            // Shuffle existing cards in the DOM
            const cardArray = Array.from(gameBoard.children);
            shuffleArray(cardArray);
            cardArray.forEach(card => gameBoard.appendChild(card));
            cards = cardArray; // Update the global cards array with new order

            // Reset and show all cards for memorization
            cards.forEach(card => {
                card.classList.remove('matched', 'showing-front');
                delete card.dataset.isMatched;
                card.classList.add('showing-content');
            });
            console.log("All cards shuffled, reset and showing content for memorization.");            let preGameCount = 5; // Memorize time
            updateActionButtonState('pre_game_countdown', preGameCount);

            await new Promise(resolve => {
                preGameCountdownTimerId = setInterval(() => {
                    preGameCount--;
                    if (preGameCount > 0) {
                        updateActionButtonState('pre_game_countdown', preGameCount);
                    } else {
                        clearInterval(preGameCountdownTimerId); preGameCountdownTimerId = null; resolve();
                    }
                }, 1000);
            });
            console.log("Memorize countdown finished.");

            // After "Memorize!" countdown, flip all cards to show their front ('?')
            cards.forEach(card => {
                setCardToShowFront(card); // This now checks for .matched internally, but shouldn't be needed here
            });
            console.log(`All cards set to show front ('?').`);

            messageArea.textContent = "Go! Find the pairs!";
            gameActive = true;
            canFlip = true; // Now player can flip cards
            updateActionButtonState('active');
            stopButton.style.display = 'inline-block'; // Show stop button

            // Add this line to show the game time display
            gameTimeDisplayElement.style.display = 'block';

            gameEndTimeStamp = Date.now() + LEVELS[currentLevelKey].gameTime;
            updateVisualGameTime();
            visualGameTimeUpdaterId = setInterval(updateVisualGameTime, 250);
            mainGameTimerId = setTimeout(() => endGame(false, "Time's Up!"), LEVELS[currentLevelKey].gameTime);
        }

        function endGame(isWin, endMessage) {
            console.log(`--- Game Ended. Win: ${isWin}, Message: ${endMessage} ---`);
            clearAllTimers(); 
            gameActive = false; 
            canFlip = false; 
            isPaused = false;
            matchedPairs = 0;
            flippedCards = [];
            
            stopButton.style.display = 'none';

            if (isWin) {
                // Show fireworks celebration
                showFireworks(3);
                // Create and show modal
                const modalOverlay = document.createElement('div');
                modalOverlay.className = 'modal-overlay';
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = '<h2>You matched them all! 🎉</h2>';
                modalOverlay.appendChild(modal);
                document.body.appendChild(modalOverlay);
                
                // Force reflow for animation
                void modalOverlay.offsetWidth;
                modalOverlay.classList.add('show');
                
                // Remove modal after 2 seconds
                setTimeout(() => {
                    modalOverlay.classList.remove('show');
                    setTimeout(() => modalOverlay.remove(), 300); // Wait for fade out
                }, 2000);
            }
            
            messageArea.textContent = endMessage + (isWin ? " 😄" : " 😕") + " Play Again?";
            updateActionButtonState('play_again');
            document.querySelectorAll('.menu-button').forEach(btn => btn.disabled = false);
        }

        function pauseGame() {
            if (!gameActive || isPaused) return;
            console.log("--- Pausing Game ---");
            
            isPaused = true;
            canFlip = false;
            
            // Store remaining time
            timeRemainingOnPause = gameEndTimeStamp - Date.now();
            
            // Clear the main game timer
            clearTimeout(mainGameTimerId);
            mainGameTimerId = null;
            
            // Update UI
            messageArea.textContent = "Game Paused";
            updateActionButtonState('paused');
        }

        function resumeGame() {
            if (!gameActive || !isPaused) return;
            console.log("--- Resuming Game ---");
            
            isPaused = false;
            canFlip = true;
            
            // Reset the end timestamp based on remaining time
            gameEndTimeStamp = Date.now() + timeRemainingOnPause;
            
            // Restart the main game timer
            mainGameTimerId = setTimeout(() => endGame(false, "Time's Up!"), timeRemainingOnPause);
            
            // Update UI
            messageArea.textContent = "Game Resumed - Keep Going!";
            updateActionButtonState('active');
        }

        function stopGame() {
            if (!gameActive) return;
            console.log("--- Stopping Game ---");
            
            clearAllTimers();
            gameActive = false;
            isPaused = false;
            canFlip = false;
            matchedPairs = 0;
            flippedCards = [];
            
            messageArea.textContent = "Game Stopped. Start a new game?";
            updateActionButtonState('initial');
            stopButton.style.display = 'none';
            document.querySelectorAll('.menu-button').forEach(btn => btn.disabled = false);
            resetAndPrepareGame();
        }

        actionButton.addEventListener('click', () => {
            const buttonText = actionButton.textContent;
            if (buttonText.includes('Start Game') || buttonText === 'Play Again?') {
                startGameSequence();
            } else if (buttonText === 'Pause') {
                pauseGame();
            } else if (buttonText === 'Resume') {
                resumeGame();
            }
        });

        stopButton.addEventListener('click', stopGame);

        // --- INITIALIZATION ---
        initializeMenus();
        resetAndPrepareGame();
        updateMenuState(categoryMenu, `category-${currentCategory}-button`);
        updateMenuState(levelMenu, `level-${currentLevelKey}-button`);

    </script>
</body>
</html>